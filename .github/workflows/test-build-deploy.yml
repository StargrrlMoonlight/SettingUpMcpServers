name: Test, Build, Deploy & Release

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

permissions:
  contents: write
  pages: write
  id-token: write
  pull-requests: write

jobs:
  # Flow 1: Comprehensive testing for PRs (both Node versions)
  test-and-build:
    name: Feature PR Tests
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'pull_request' &&
      !startsWith(github.head_ref, 'automated-release/') &&
      !contains(github.event.pull_request.title, 'chore: release') &&
      !contains(github.event.pull_request.title, '[skip ci]') &&
      github.event.pull_request.user.login != 'github-actions[bot]'
    
    strategy:
      matrix:
        node-version: [18.x, 20.x]

    outputs:
      coverage: ${{ steps.coverage.outputs.coverage }}
      build-success: ${{ steps.build.outputs.success }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
        persist-credentials: true
        
    - name: Setup Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Run ESLint
      run: npm run lint

    - name: Run tests with coverage
      run: npm run test:ci
      
    - name: Extract coverage percentage
      id: coverage
      if: matrix.node-version == '20.x'  # Only extract once
      run: |
        COVERAGE=$(cat coverage/coverage-summary.json | jq -r '.total.lines.pct')
        echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT
        echo "ğŸ“Š Test coverage: $COVERAGE%"
        
    - name: Build application
      id: build
      run: |
        npm run build
        echo "success=true" >> $GITHUB_OUTPUT

    - name: Run accessibility tests
      if: matrix.node-version == '20.x'  # Only run accessibility tests once
      run: |
        echo "ğŸ” Running accessibility tests on built application..."
        npm run test:a11y
      continue-on-error: false  # Fail the workflow if accessibility tests fail

  # Flow 2: Detect human merge and determine release needs (EXCLUDE automated commits)
  check-human-merge:
    name: Detect Human Merge & Release Planning
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'push' && 
      github.ref == 'refs/heads/main' &&
      !contains(github.event.head_commit.message, '[skip ci]') &&
      !contains(github.event.head_commit.message, 'chore: release v') &&
      !contains(github.event.head_commit.message, 'automated release preparation') &&
      github.event.head_commit.author.email != 'actions@github.com' &&
      github.event.head_commit.author.email != '41898282+github-actions[bot]@users.noreply.github.com' &&
      github.event.head_commit.author.name != 'GitHub Actions'
    
    outputs:
      should-release: ${{ steps.release-check.outputs.should-release }}
      next-version: ${{ steps.release-check.outputs.next-version }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
      
    - name: Validate this is a human merge
      run: |
        echo "ğŸ” Validating this is a legitimate human merge..."
        echo "Commit author: ${{ github.event.head_commit.author.name }}"
        echo "Commit email: ${{ github.event.head_commit.author.email }}"
        echo "Commit message: ${{ github.event.head_commit.message }}"
        
        # Additional check for automated commits that might slip through
        if echo "${{ github.event.head_commit.message }}" | grep -qiE "(automated|bot|github-actions|skip.ci|release.v[0-9])"; then
          echo "âŒ This appears to be an automated commit - stopping workflow"
          exit 1
        fi
        
        echo "âœ… Confirmed: This is a human-initiated merge"
      
    - name: Check release eligibility
      id: release-check
      run: |
        echo "ğŸ¯ Human merge detected - checking if release is needed"
        
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        echo "Latest tag: $LATEST_TAG"
        
        if [ "$LATEST_TAG" = "v0.0.0" ]; then
          COMMITS_SINCE_TAG=1
        else
          COMMITS_SINCE_TAG=$(git rev-list ${LATEST_TAG}..HEAD --count)
        fi
        
        echo "Commits since last tag: $COMMITS_SINCE_TAG"
        
        if [ "$COMMITS_SINCE_TAG" -gt 0 ]; then
          echo "should-release=true" >> $GITHUB_OUTPUT
          
          if [ "$LATEST_TAG" = "v0.0.0" ]; then
            NEW_VERSION="v1.0.0"
            echo "ğŸ‰ First release detected"
          else
            # Your existing version calculation logic...
            TAG_VERSION=$(echo $LATEST_TAG | sed 's/^v//')
            IFS='.' read -r MAJOR MINOR PATCH <<< "$TAG_VERSION"
            
            COMMIT_MESSAGES=$(git log ${LATEST_TAG}..HEAD --oneline)
            echo "ğŸ” Analyzing commits since $LATEST_TAG:"
            echo "$COMMIT_MESSAGES"
            
            if echo "$COMMIT_MESSAGES" | grep -qiE "(BREAKING CHANGE|breaking change)"; then
              NEW_VERSION="v$((MAJOR + 1)).0.0"
              echo "ğŸš¨ Major version bump detected (breaking change)"
            elif echo "$COMMIT_MESSAGES" | grep -qiE "(fix|patch)"; then
              NEW_VERSION="v${MAJOR}.${MINOR}.$((PATCH + 1))"
              echo "ğŸ”§ Patch version bump detected (fix or patch)"
            else
              NEW_VERSION="v${MAJOR}.$((MINOR + 1)).0"
              echo "ğŸ“¦ Minor version bump (default for all other commits)"
            fi
          fi
          
          echo "next-version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "ğŸ¯ Next release version: $NEW_VERSION"
        else
          echo "should-release=false" >> $GITHUB_OUTPUT
        fi

  # Flow 2 Continued: Production build + version update (ALWAYS fresh build)
  production-pipeline:
    name: Production Pipeline
    runs-on: ubuntu-latest
    needs: [check-human-merge]
    if: needs.check-human-merge.result == 'success'
  
    outputs:
      coverage: ${{ steps.get-coverage.outputs.coverage }}
      build-success: ${{ steps.build.outputs.success }}
      pr-created: ${{ steps.create-pr.outputs.pr-created }}
      pr-number: ${{ steps.create-pr.outputs.pr-number }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.RELEASE_PAT }}
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20.x'
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci

    # SKIP ESLint - already validated in PR
    # SKIP accessibility tests - already validated in PR

    - name: Run minimal smoke test for coverage extraction
      run: |
        echo "ğŸ”¥ Running minimal smoke test to extract coverage (code already validated in PR)..."
        npm run test:ci

    - name: Extract coverage percentage
      id: get-coverage
      run: |
        echo "ğŸ§ª Running fresh test suite for accurate coverage..."
        COVERAGE=$(cat coverage/coverage-summary.json | jq -r '.total.lines.pct')
        echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT
        echo "ğŸ“Š Test coverage: $COVERAGE%"

    - name: Build application
      id: build
      run: |
        echo "ğŸ”¨ Building application for production..."
        npm run build
        echo "success=true" >> $GITHUB_OUTPUT

    # Version update PR creation (only for Node 20.x and if release needed)
    - name: Create version update PR
      id: create-pr
      if: |
        needs.check-human-merge.outputs.should-release == 'true' &&
        steps.build.outputs.success == 'true'
      run: |
        echo "ğŸ”„ Creating SILENT version update PR for release process"
        
        VERSION="${{ needs.check-human-merge.outputs.next-version }}"
        CLEAN_VERSION=$(echo $VERSION | sed 's/^v//')
        COVERAGE="${{ steps.get-coverage.outputs.coverage }}"
        BRANCH_NAME="automated-release/${VERSION}"
        
        # Configure git
        git config --local user.name "GitHub Actions"
        git config --local user.email "actions@github.com"
        
        # Create branch and update files
        git checkout -b "$BRANCH_NAME"
        npm version $CLEAN_VERSION --no-git-tag-version
        
        # Update coverage badge
        COVERAGE_INT=$(echo "$COVERAGE" | cut -d. -f1)
        if [ "$COVERAGE_INT" -ge 90 ]; then COLOR="brightgreen"
        elif [ "$COVERAGE_INT" -ge 80 ]; then COLOR="green"
        elif [ "$COVERAGE_INT" -ge 70 ]; then COLOR="yellowgreen"
        elif [ "$COVERAGE_INT" -ge 60 ]; then COLOR="yellow"
        elif [ "$COVERAGE_INT" -ge 50 ]; then COLOR="orange"
        else COLOR="red"; fi
        
        NEW_BADGE="![Coverage](https://img.shields.io/badge/coverage-${COVERAGE}%25-${COLOR})"
        
        if grep -q "!\[Coverage\]" README.md; then
          sed -i "s|!\[Coverage\][^)]*|$NEW_BADGE|g" README.md
        else
          sed -i "1a\\$NEW_BADGE" README.md
        fi
        
        # Generate CHANGELOG
        echo "# Changelog" > CHANGELOG.md
        echo "" >> CHANGELOG.md
        echo "## [$VERSION] - $(date '+%Y-%m-%d')" >> CHANGELOG.md
        echo "" >> CHANGELOG.md
        echo "### Quality Metrics" >> CHANGELOG.md
        echo "- Test coverage: ${COVERAGE}%" >> CHANGELOG.md
        echo "- Accessibility tests: âœ… Passed" >> CHANGELOG.md
        echo "- ESLint validation: âœ… Passed (validated in PR)" >> CHANGELOG.md
        echo "" >> CHANGELOG.md
        
        # Commit with [skip ci] to prevent triggering workflows
        git add package.json package-lock.json README.md CHANGELOG.md
        git commit -m "chore: release $VERSION [skip ci]

        - Update package.json version to $CLEAN_VERSION
        - Update coverage badge to ${COVERAGE}%
        - Generate CHANGELOG.md
        
        This is an automated release preparation commit."
        
        # Push and create PR with [skip ci] in title
        git push https://x-access-token:${{ secrets.RELEASE_PAT }}@github.com/${{ github.repository }}.git "$BRANCH_NAME"
        
        PR_URL=$(gh pr create \
          --title "chore: release $VERSION [skip ci]" \
          --body "ğŸš€ **AUTOMATED RELEASE PREPARATION** - SILENT MODE

        âš ï¸ **This PR is automated and should NOT trigger any CI workflows**

        ## Changes
        - ğŸ“¦ Updated \`package.json\` version to \`$CLEAN_VERSION\`
        - ğŸ“ Updated \`CHANGELOG.md\` with release information  
        - ğŸ“Š Updated coverage badge to \`${COVERAGE}%\`
        
        ## Quality Assurance (Already Validated in PR)
        - âœ… Tests passed with ${COVERAGE}% coverage *(PR validation)*
        - âœ… Accessibility tests passed *(PR validation)*
        - âœ… ESLint validation passed *(PR validation)*
        - âœ… Build successful on Node 18.x and 20.x *(PR validation)*
        
        ## Silent Mode
        - âŒ No tests run (already validated in production pipeline)
        - âŒ No builds run (fresh build happens after merge)
        - âœ… Auto-merge enabled for immediate processing
        
        ---
        
        ğŸ¤– This PR will be **automatically merged** to proceed with the release process." \
          --head "$BRANCH_NAME" \
          --base main)
        
        PR_NUMBER=$(echo "$PR_URL" | grep -o '[0-9]*$')
        gh pr merge "$PR_NUMBER" --auto --squash --delete-branch
        
        echo "pr-created=true" >> $GITHUB_OUTPUT
        echo "pr-number=$PR_NUMBER" >> $GITHUB_OUTPUT
        
        echo "âœ… SILENT automated PR created: #$PR_NUMBER"
        echo "ğŸ”‡ This PR will NOT trigger any CI workflows"
        
      env:
        GH_TOKEN: ${{ secrets.RELEASE_PAT }}

    - name: Upload production build artifacts
      uses: actions/upload-artifact@v4
      if: steps.build.outputs.success == 'true'
      with:
        name: production-build-${{ github.sha }}
        path: dist/
        retention-days: 30

  # Wait for version PR merge, then build fresh with updated files
  post-version-update-build:
    name: Final Build with Updated Version
    runs-on: ubuntu-latest
    needs: [check-human-merge, production-pipeline]
    if: |
      needs.production-pipeline.result == 'success' &&
      needs.check-human-merge.outputs.should-release == 'true'
    
    outputs:
      build-success: ${{ steps.build.outputs.success }}
    
    steps:
    # Wait for version PR merge
    - name: Wait for SILENT version PR merge
      if: needs.production-pipeline.outputs.pr-created == 'true'
      run: |
        echo "ğŸ• Waiting for SILENT version update PR to merge..."
        echo "PR #${{ needs.production-pipeline.outputs.pr-number }} (should not trigger any workflows)"
        
        TIMEOUT=300
        ELAPSED=0
        INTERVAL=15
        
        while [ $ELAPSED -lt $TIMEOUT ]; do
          echo "â³ Checking SILENT PR #${{ needs.production-pipeline.outputs.pr-number }} status... (${ELAPSED}s elapsed)"
          
          PR_STATE=$(gh pr view "${{ needs.production-pipeline.outputs.pr-number }}" --json state,merged --jq '.state + "|" + (.merged | tostring)' 2>/dev/null || echo "unknown|false")
          STATE=$(echo "$PR_STATE" | cut -d'|' -f1)
          MERGED=$(echo "$PR_STATE" | cut -d'|' -f2)
          
          if [ "$STATE" = "MERGED" ] || [ "$MERGED" = "true" ]; then
            echo "âœ… SILENT PR #${{ needs.production-pipeline.outputs.pr-number }} merged successfully!"
            echo "ğŸ”‡ Confirmed: No CI workflows were triggered"
            break
          elif [ "$STATE" = "CLOSED" ] && [ "$MERGED" = "false" ]; then
            echo "âŒ SILENT PR #${{ needs.production-pipeline.outputs.pr-number }} was closed without merging!"
            exit 1
          fi
          
          sleep $INTERVAL
          ELAPSED=$((ELAPSED + INTERVAL))
        done
        
      env:
        GH_TOKEN: ${{ secrets.RELEASE_PAT }}

    # Fresh checkout with updated version files
    - name: Checkout updated main branch
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        ref: main
        token: ${{ secrets.RELEASE_PAT }}
        
    - name: Pull latest changes with version updates
      run: |
        echo "ğŸ”„ Getting latest main with version updates..."
        git pull origin main
        
        # Verify version was updated
        CURRENT_VERSION=$(node -p "require('./package.json').version")
        EXPECTED_VERSION=$(echo "${{ needs.check-human-merge.outputs.next-version }}" | sed 's/^v//')
        
        echo "Current package.json version: $CURRENT_VERSION"
        echo "Expected version: $EXPECTED_VERSION"
        
        if [ "$CURRENT_VERSION" = "$EXPECTED_VERSION" ]; then
          echo "âœ… Version correctly updated to $CURRENT_VERSION"
        else
          echo "âŒ Version mismatch - expected $EXPECTED_VERSION, got $CURRENT_VERSION"
          exit 1
        fi

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20.x'
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci

    - name: Build application with updated version
      id: build
      run: |
        echo "ğŸ”¨ Building final production version with updated files..."
        npm run build
        echo "âœ… Final build completed successfully!"
        echo "success=true" >> $GITHUB_OUTPUT

    - name: Run final accessibility validation
      run: |
        echo "ğŸ” Running final accessibility validation on release build..."
        npm run test:a11y
      continue-on-error: false  # Fail the workflow if accessibility tests fail

    - name: Upload final build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: final-build-${{ github.sha }}
        path: dist/
        retention-days: 30

  # Deploy and Release (using fresh build with updated version)
  deploy-and-release:
    name: Deploy & Release
    runs-on: ubuntu-latest
    needs: [check-human-merge, production-pipeline, post-version-update-build]
    # EXCLUDE automated commits from deployment
    if: |
      github.event.head_commit.author.email != 'actions@github.com' &&
      !contains(github.event.head_commit.message, '[skip ci]') &&
      (
        (needs.check-human-merge.outputs.should-release == 'false' && needs.production-pipeline.outputs.build-success == 'true') ||
        (needs.check-human-merge.outputs.should-release == 'true' && needs.post-version-update-build.outputs.build-success == 'true')
      )
    
    steps:
    # Download the appropriate build artifacts
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: ${{ needs.check-human-merge.outputs.should-release == 'true' && 'final-build-' || 'production-build-' }}${{ github.sha }}
        path: ./dist
        
    - name: Setup Pages
      uses: actions/configure-pages@v4
      
    - name: Upload pages artifact
      uses: actions/upload-pages-artifact@v3
      with:
        path: ./dist
        
    - name: Deploy to GitHub Pages
      id: deployment
      uses: actions/deploy-pages@v4

    # Create GitHub Release (if needed)
    - name: Create GitHub Release
      if: needs.check-human-merge.outputs.should-release == 'true'
      run: |
        # Checkout latest main (with version updates)
        git clone https://x-access-token:${{ secrets.RELEASE_PAT }}@github.com/${{ github.repository }}.git .
        git checkout main
        
        VERSION="${{ needs.check-human-merge.outputs.next-version }}"
        COVERAGE="${{ needs.production-pipeline.outputs.coverage }}"
        
        # Create git tag
        git config --local user.name "GitHub Actions"
        git config --local user.email "actions@github.com"
        git tag -a "$VERSION" -m "Release $VERSION"
        git push origin "$VERSION"
        
        # Create release archives from final build
        cd dist
        tar -czf ../todo-app-$VERSION.tar.gz .
        zip -r ../todo-app-$VERSION.zip .
        cd ..
        
        # Create GitHub release
        gh release create "$VERSION" \
          --title "Release $VERSION" \
          --notes "ğŸš€ Automated release with ${COVERAGE}% test coverage

        ## ğŸ“Š Quality Metrics
        - Test Coverage: ${COVERAGE}%
        - Node.js Versions Tested: 18.x, 20.x
        - Accessibility Tests: âœ… Passed
        - Build Status: âœ… Success

        ## ğŸ” Accessibility Compliance
        This release has been validated for accessibility compliance following WCAG guidelines.

        ## ğŸŒ Live Demo
        [View Live Demo](${{ steps.deployment.outputs.page_url }})

        **Full Changelog**: https://github.com/${{ github.repository }}/compare/$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo 'initial')...$VERSION" \
          --latest \
          todo-app-$VERSION.tar.gz \
          todo-app-$VERSION.zip
          
      env:
        GH_TOKEN: ${{ secrets.RELEASE_PAT }}

    - name: Summary
      run: |
        echo "ğŸ‰ Optimized workflow completed!"
        echo "ğŸ“Š Coverage: ${{ needs.production-pipeline.outputs.coverage }}%"
        echo "ğŸ” Accessibility: âœ… Validated"
        echo "ğŸŒ Live Demo: ${{ steps.deployment.outputs.page_url }}"
        if [ "${{ needs.check-human-merge.outputs.should-release }}" = "true" ]; then
          echo "ğŸš€ Release ${{ needs.check-human-merge.outputs.next-version }} created with fresh build"
          echo "ğŸ”‡ Automated PRs were completely silent (no CI triggered)"
        fi